Data packet generator initial documentation

The overall goal of this data packet generator is to generate a cpp and fortran class
that contains a data packet specified by the user for use on the GPU. 
The user should be able to specify constants and arrays with any name for use on the gpu.
The array types should be generic, there can be n arrays in any section, that can hold any
data type, have any dimensionality, and any extents.

A call to the data packet generator requires a JSON object of the format
specified in this documentation.

The user can call the datapacket generator like so:

    python packet_generator.py [datapacket_file.json]

or, if imported, the user can call one of the various functions inside the python file,
as long as an open file and python dict is passed in. 

All available json sections are described below. Any default values for keys are
put in [brackets] if it exists.

Packet Metadata:

[Required]	
- name	= the name of the data packet to be generated.
- ndim  = the number of dimensions being used. [3] (Should we force the user to specify ndims?)
- byte-align = The requested byte alignment value. [16]
- start = index where the unknown variables start ( variable masking ). Can be an int or a known runtime constant. Strings print out a warning (for now).
- end = index where the unknown variables end ( variable masking ). Can be an int or known runtime constant. Strings print out a warning (for now).

[Optional]
- n-extra-streams = the number of extra streams to use in the packet. Every datapacket has at least one stream. [0]

Other Sections:

[Required]

general:
    Non tile specific data goes in here. Number of tiles, dt, PacketContents, or any calculation constants should go here.
    Note: Number of tiles and PacketContents are generated automatically. You should not specify them in the packet.
    However, you must specify dt. Any items in general must be passed into the datapacket constructor, and the datapacket
    will take ownership of the items and copy them into its own memory to manage it. We are assuming the items will remain
    valid throughout the life cycle of the entire packet.

[optional]

tile-in
    The set of array types that we want to be included in the input section per Tile
    for the packet.

tile-in-out
    The array type data that should be used for both copying into and copying out of the gpu per tile.

tile-out
    The array types that we want to contain the outputs of the calculations done in the gpu.

tile-metadata
    All of the metadata to be included per tile.

tile-scratch
    All scratch arrays to be included per tile.

If a scalar is being identified as a key, you must include the data type as the value for that key.

Array Type Specification:

When specifying array types, 2 things must be included. The type that the array stores and the extents of the array.
The number of unknown variables or fluxes must be specified in the last position of the array.

Anything in extents should be specified as a string to make generation easier.

"array_type_name": {
    "type": "data_type"
    "dim": [number] (default is 4 if not specified.)
    "extents": *
}

*   There are 2 options for extents, one is a string containing the type of indexer 
    as well as the number of guard cells and number of unknown variables. You can set
    numbers, or use a preset macro such as NGUARD, NUNKVARS, or NFLUXES. 

        ex: "cc(NGUARD, NUNKVARS)"

    Or, you can directly specify the extents of the array using a list of 4 numbers.

        ex: [16, 16, 1, 4]